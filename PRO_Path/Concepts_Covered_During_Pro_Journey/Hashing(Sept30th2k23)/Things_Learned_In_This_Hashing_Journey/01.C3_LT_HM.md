# Rahul baically just to remind you these approach's mentioned below are the  best and optimized but they are not your inital thoughts try to add these approach's to your already existing Rich Array of approach's.

## Problem is [Merge_Two_Array's](https://leetcode.com/problems/merge-similar-items/description/)

### When to use the below approach shared

**When you have 2 or more containers and need to perform a operation to it's unique elements scope is Hashmap and Below Approach**

### Issue's I Have seen

01. Using HashMap does require interation's of the containers

02. Space allocated to each distinct element in the memory.

Space Complexity is O(A unique elements in Container 1 + .... + ZZ Unique elements in Container n).
		    O(N+M)Logn(Ordered_Map will using sorting internally so we use XLogN complexity)

Time Complexity is O(A time for the X elements in container 1 + ...... + ZZ Unique elements in Container n)
		   O(N+M)

### Scope for Optimization

01. Space Complexity -> Suppose i want to use the constant space complexity O(1) then we shouldn't be having an variable size of elements in Hashmap.
		     -> So, Can we avoid hashmap and Still keep track of unique elements with key's and so summation of the values in different array's.

**Solution**
*I will use the Sort method to sort everything in the containers and then i will do summation of the similar elements while iterating and if there are element's which are not similar then the smallest will be pushed into it and we will go it's next possible highest value in the hope of matching it with the element in the other container as the smallest element is pushed.*

**Let's consider a usecase example**

|A|B|
|-|-|
|1|1|
|2|3|
|4|4|

*In the above example in 1st iteration we go with similar vaules in index 0 next iteration we go with value in A as it is smaller than b so use the value in A and increment it's position and now we compare again (4 to 3).So, now the B is smaller so we push value B into the result and move forward now we have similar values now we sum up the weight's*

```cpp

while(a<n&&b<m)
{
	if(a[i][0]===b[j][0]){result.push_back({a[i][0],a[i][1]+b[j][1]});++i;++j;}
	else if(a[i][0]<b[i][0]){result.push_back(a[i]);++i;}//Now the key and value pushed the way they are.
	else {result.push_back(b[j]);++j;} //if B is less than A
}
// if either A or B reaches to the end of their length the above loop will be terminated leaving the other conatiner untraversed
// So, we can check if i,j have reached to their end length or not if not we can traverse and complete the remaing action.
while(i<a.size())
{result.push_back(a[i]);++i;}
while(j<b.size())
{result.push_back(b[j]);++j;}

```


## Problem 02: [Points That Intersect The Cars](https://leetcode.com/problems/points-that-intersect-with-cars/description/)

### Issue Observed.

01. I have already optimized using just a single iteration but it looks like there is an scope for furthur optimization.

02. The Time complexity is O(n*n) in an edge case.

### Scope of Optimization

01. why do we even have to traverse i am using frequency array to keep track to elements which have occurred so far.
  -> But here we aren't doing anything with it's frequency we just want to know about it's occurance and store that occurance
  -> When a uniqueness come's into picture we can lean towards set's and also freq array(Which i have used prior) but in it we need to spare few repated operations which could be avoided if we just relay upon the set's alone.

#### Brute_Force

```cpp

void func(vector<int> &freq,vector<int> element)
    {
        int st=element[0]-1,sp=element[1]-1;
        for(int i=st;i<=sp;++i)
        {
            freq[i]++;
        }
    }

vector<int> freq(100,0);
        int idx=-1,Min=INT_MAX,Max=INT_MIN,len=0:
        for(auto x:nums)
        {
            func(freq,x);
            // a=x[0];
            // b=x[1];
            // if(a<Min){Min=a;}
            // if(a>Max){Max=a;}
            // if(b<Min){Min=b;}
            // if(b>Max){Max=b;}
        }
        // for(int i=Min-1;i<Max;i++)
        // {
        //     if(freq[i]>0)len++;
        // }
        for(auto x:freq)
        {
            if(x>0)len++;
        }
        return len;

``` 

#### Optimized

```cpp

        int len=0,st,sp;
        int data[100]={0};
        for(vector<int> x:nums)
        {st=x[0];
        sp=x[1];
            for(int i=st;i<=sp;++i)
            {
                if(data[i-1]==0)
                {len++;
                data[i-1]++;}
            }
        }
        return len;

```


#### Hyper Optimized

```cpp

--> Not able to find one but set's seem's convencing but didn't surpass the expectations.

```


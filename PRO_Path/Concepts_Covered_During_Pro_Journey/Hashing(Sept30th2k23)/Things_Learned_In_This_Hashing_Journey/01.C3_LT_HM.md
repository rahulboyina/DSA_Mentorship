# Rahul baically just to remind you these approach's mentioned below are the  best and optimized but they are not your inital thoughts try to add these approach's to your already existing Rich Array of approach's.

## Problem is [Merge_Two_Array's](https://leetcode.com/problems/merge-similar-items/description/)

### Issue's I Have seen

01. Using HashMap does require interation's of the containers

02. Space allocated to each distinct element in the memory.

Space Complexity is O(A unique elements in Container 1 + .... + ZZ Unique elements in Container n).
		    O(N+M)Logn(Ordered_Map will using sorting internally so we use XLogN complexity)

Time Complexity is O(A time for the X elements in container 1 + ...... + ZZ Unique elements in Container n)
		   O(N+M)

### Scope for Optimization

01. Space Complexity -> Suppose i want to use the constant space complexity O(1) then we shouldn't be having an variable size of elements in Hashmap.
		     -> So, Can we avoid hashmap and Still keep track of unique elements with key's and so summation of the values in different array's.

**Solution**
*I will use the Sort method to sort everything in the containers and then i will do summation of the similar elements while iterating and if there are element's which are not similar then the smallest will be pushed into it and we will go it's next possible highest value in the hope of matching it with the element in the other container as the smallest element is pushed.*

**Let's consider a usecase example**

|A|B|
|-|-|
|1|1|
|2|3|
|4|4|

*In the above example in 1st iteration we go with similar vaules in index 0 next iteration we go with value in A as it is smaller than b so use the value in A and increment it's position and now we compare again (4 to 3).So, now the B is smaller so we push value B into the result and move forward now we have similar values now we sum up the weight's*

```cpp

while(a<n&&b<m)
{
	if(a[i][0]===b[j][0]){result.push_back({a[i][0],a[i][1]+b[j][1]});++i;++j;}
	else if(a[i][0]<b[i][0]){result.push_back(a[i]);++i;}//Now the key and value pushed the way they are.
	else {result.push_back(b[j]);++j;} //if B is less than A
}
// if either A or B reaches to the end of their length the above loop will be terminated leaving the other conatiner untraversed
// So, we can check if i,j have reached to their end length or not if not we can traverse and complete the remaing action.
while(i<a.size())
{result.push_back(a[i]);++i;}
while(j<b.size())
{result.push_back(b[j]);++j;}

```
